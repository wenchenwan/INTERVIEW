# 数据结构与算法补充部分

## 查找算法

无序表查找

1. ​	暴力

有序表查找

1. 二分查找
2. 插值查找
3. 斐波那契查找

线性索引查找

1. 稠密索引
2. 分块索引
3. 倒排索引

二叉排序树

1. 构造、查找、插入、删除
2. 基本操作

平衡二叉树

1. 构造、查找、插入、删除
2. 基本操作

了解性的原理

1. 多路查找树（B树）

   1. 2-3树
   2. 2-3-4树
   3. B树
   4. B+树（为了解决中序遍历要不停从磁盘读入读出数据的次数）

2. 散列表（哈希表）概述

   位置与关键字进行映射，实现O(1)时间查找

   1. 哈希函数的构造方法：

      1. 直接定址法
      2. 数字分析法
      3. 平方取中法
      4. 折叠法
      5. 除数留余法（最常用的方法）
      6. 随机数法

   2. 处理哈希冲突的方法

      1. 开放定址法

         1. 线性探测法
         2. 二次探测法
         3. 随机探测法

      2. 再散列函数法

         冲突时候更换散列函数来寻找直到不冲突的散列函数

      3. 链地址法

         如果在某一点发生冲突，就利用单链表实现节点的增加，来解决哈希函数的冲突

      4. 公共溢出区法

         建立一块公共溢出区来保存在构造哈希函数冲突时候的元素。

## 排序算法

1. 排序的稳定性（排序前后大小相同的元素位置是否会发生交换）

2. 内排序（主要）与外排序

3. 内排序的性能：时间性能、辅助空间、算法复杂性

4. 主要排序算法类型

   1. 冒泡排序

      1. 交换排序

      2. 冒泡排序

         第二层循环倒叙实现（j > i）

         交换的元素为第二层的swap（j，j+1）；

      3. 冒泡排序的优化

         在排序中增加一个FLAG，如果一轮循环中没有产生任何的交换，FLAG就为FALSE，表示已经完成排序

   2. 选择排序

   3. 直接插入排序

      ![img](https://raw.githubusercontent.com/wenchenwan/CloudPic/master/img/20180717094120320)

   4. [希尔排序](https://www.bilibili.com/video/BV1rE411g7rW?share_source=copy_web)

      ```c++
      while(分组间隔减小 )
      	选择分组间隔分组
      	组内排序
      ```

   5. [堆排序](https://www.bilibili.com/video/BV1Eb41147dK?share_source=copy_web)

      完全二叉树：生成节点需要满足从上往下从左往右的顺序<img src="https://raw.githubusercontent.com/wenchenwan/CloudPic/master/img/image-20211116152244402.png" alt="image-20211116152244402" style="zoom: 25%;" />

      堆的概念（heap）：堆是具有以下性质的完全二叉树，每个节点都大于等于其左右孩子节点的数值，我们称之为大顶堆，每个节点都小于等于其左右孩子节点的数值，我们称之为小顶堆。

      将一个树转换为堆的过程（heapify）：在三个节点之间找到最大值与父节点进行交换即可。

       <img src="https://raw.githubusercontent.com/wenchenwan/CloudPic/master/img/image-20211116153844385.png" alt="image-20211116153844385" style="zoom: 33%;" />

      ```c++
      #include<stdio.h>
      void swap(int arr[],int i,int j){
           int temp = arr[i];
           arr[i] = arr[j];
           arr[j] = temp;
      }
      
      void heapify(int tree[],int n,int i){
           if(i>=n) return;
           int c1 = 2*i+1;
           int c2 = 2*i+2;
      
           int max = i;
           if(c1<n && tree[c1]>tree[max]){
              max = c1;
           }
           if(c2<n && tree[c2] >tree[max]){
              max = c2;
           }
           if(max != i){
              swap(tree,max,i);
              //heapify(tree,n,max);
           }
      }
      
      void buildHeap(int tree[],int n){
           int last_node = n-1;
           int parent = (last_node-1)/2;
           int i;
           for(i=parent;i>=0;i--){
              heapify(tree,n,i);
           }
      }
      
      void heapSort(int tree[],int n){
           buildHeap(tree,n);
           int i;
           for(i=n-1;i>=0;i--){
              swap(tree,i,0);
               //将最后一个元素与堆顶的元素进行交换（剪枝）
              heapify(tree,i,0);
           }
      
      }
      
      
      int main(){
          //int tree[] = {4,10,3,5,1,2};
          int tree[] = {2,5,3,1,10,4};
      
          int n = 6;
          //heapify(tree,n,0);
          //buildHeap(tree,n);
          heapSort(tree,n);
          int i;
          for(;i<n;i++){
              printf("%d\n",tree[i]);
          }
          return 0;
      }
      ```

   6. [归并排序](https://www.bilibili.com/video/BV1Ax411U7Xx?share_source=copy_web)

      基本原理：就是将两个有序的列表通过使用设计算法来实现合并起来。

      <img src="https://raw.githubusercontent.com/wenchenwan/CloudPic/master/img/image-20211116195140070.png" alt="image-20211116195140070" style="zoom:50%;" />

      归并排序的例子

      <img src="https://raw.githubusercontent.com/wenchenwan/CloudPic/master/img/image-20211116195425191.png" alt="image-20211116195425191" style="zoom:33%;" />

      <img src="https://raw.githubusercontent.com/wenchenwan/CloudPic/master/img/image-20211116201409130.png" alt="image-20211116201409130" style="zoom:50%;" />

      将两个有序数组写入一个 长的新数组中即可。

      实际归并排序代码

      ```c++
      #include<stdio.h>
      void merge(int arr[],int L,int N,int R){
          const int LEFT_SIZE = N-L;
          const int RIGHT_SIZE = R-N+1;
          int left[LEFT_SIZE];
          int right[RIGHT_SIZE];
      
          int i,j,k;
          //1. Fill in the left sub array
          for(i=0;i<N;i++){
              left[i-L] = arr[i];
      
          }
          //1. Fill in the right sub array
      
          for(i=N;i<=R;i++){
              right[i-N] = arr[i];
          }
      
          //for(i=0;i<N;i++){
          //      printf("%d\n",left[i]);
          //}
          i=0;j=0;k=L;
          while(i<LEFT_SIZE && j <RIGHT_SIZE){
              if(left[i]<right[j]){
                  arr[k] = left[i];
                  k++;
                  i++;
              }else{
                  arr[k] = right[j];
                  j++;
                  k++;
              }
          }
          while(i<LEFT_SIZE){
              arr[k] = left[i];
              k++;i++;
      
          }
          while(j<RIGHT_SIZE){
              arr[k] = right[j];
              k++;j++;
          }
      }
      
      void MergeSort(int arr[],int L,int R){
          if(L==R) return;
          int M = (L+R)/2;
          MergeSort(arr,L,M);
          MergeSort(arr,M+1,R);
          merge(arr,L,M+1,R);
      
      }
      
      int main(){
          int arr[] = {6,8,10,9,4,5,2,7};
          int L = 0;
          int R = 7;
          int N = 4;
          int i;
          //merge(arr,L,N,R);
          MergeSort(arr,L,R);
          for(i = 0;i<R;i++){
              printf("%d\n",arr[i]);
          }
          return 0;
      }
      ```

   7. 快速排序

      **基本思想**：

      <img src="https://raw.githubusercontent.com/wenchenwan/CloudPic/master/img/image-20211116220206188.png" alt="image-20211116220206188" style="zoom: 40%;" />

      **代码实现部分**

      ```c++
      void QuickSort(int arr[],int L,int R){
              if(L>=R) return;
              int left = L;
              int right = R;
              int pivot = arr[left];
      
              while(left < right){
                      while(left < right && arr[right]>=pivot){
                              right--;
                      }
                      if(left<right){
                              arr[left] = arr[right];
                      }
      
                      while(left < right && arr[left] <= pivot){
                              left++;
                      }
                      if(left<right){
                              arr[right] = arr[left];
                      }
                      if(left >= right){
                              arr[left] = pivot;
                      }
      
              }
      
              QuickSort(arr,L,right-1);
              QuickSort(arr,right+1,R);
      
      }
      
      ```

